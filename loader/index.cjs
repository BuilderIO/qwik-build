const QWIK_LOADER = "(()=>{const t=(t,e,n)=>(t=t.closest(\"[q\\\\:container]\"),new URL(e,new URL(t?t.getAttribute(\"q:base\"):n,n))),e=t=>{throw Error(\"QWIK: \"+t)};((n,o)=>{const s=\"__q_context__\",r=[\"on:\",\"on-window:\",\"on-document:\"],a=(t,e,o)=>{e=e.replace(/([A-Z])/g,(t=>\"-\"+t.toLowerCase())),n.querySelectorAll(\"[on\"+t+\"\\\\:\"+e+\"]\").forEach((t=>c(t,e,o)))},i=(t,e)=>t.dispatchEvent(new CustomEvent(\"qSymbol\",{detail:{name:e},bubbles:!0,composed:!0})),c=async(o,a,c)=>{for(const u of r){const r=o.getAttribute(u+a);if(r){o.hasAttribute(\"preventdefault:\"+a)&&c.preventDefault();for(const a of r.split(\"\\n\")){const r=t(o,a,n.baseURI);if(r){const t=l(r),a=(window[r.pathname]||await import(r.href.split(\"#\")[0]))[t]||e(r+\" does not export \"+t),u=n[s];try{n[s]=[o,c,r],a(c,o,r)}finally{n[s]=u,i(o,t)}}}}}},l=t=>t.hash.replace(/^#?([^?[|]*).*$/,\"$1\")||\"default\",u=(t,e)=>{if((e=t.target)==n)setTimeout((()=>a(\"-document\",t.type,t)));else for(;e&&e.getAttribute;)c(e,t.type,t),e=t.bubbles?e.parentElement:null},p=t=>n.addEventListener(t,u,{capture:!0}),d=t=>{t=n.readyState,o||\"interactive\"!=t&&\"complete\"!=t||(o=1,a(\"\",\"q-init\",new CustomEvent(\"qInit\")))};{const t=n.querySelector(\"script[events]\");if(t)t.getAttribute(\"events\").split(/[\\s,;]+/).forEach(p);else for(const t in n)t.startsWith(\"on\")&&p(t.slice(2))}n.addEventListener(\"readystatechange\",d),d()})(document)})();";
const QWIK_LOADER_DEBUG = "!function() {\n    /**\n * @license\n * Copyright Builder.io, Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/BuilderIO/qwik/blob/main/LICENSE\n */\n    const qrlResolver = (element, eventUrl, baseURI) => {\n        element = element.closest(\"[q\\\\:container]\");\n        return new URL(eventUrl, new URL(element ? element.getAttribute(\"q:base\") : baseURI, baseURI));\n    };\n    const error = msg => {\n        throw new Error(\"QWIK: \" + msg);\n    };\n    ((doc, hasInitialized) => {\n        const ON_PREFIXES = [ \"on:\", \"on-window:\", \"on-document:\" ];\n        const broadcast = (infix, type, ev) => {\n            type = type.replace(/([A-Z])/g, (a => \"-\" + a.toLowerCase()));\n            doc.querySelectorAll(\"[on\" + infix + \"\\\\:\" + type + \"]\").forEach((target => dispatch(target, type, ev)));\n        };\n        const symbolUsed = (el, symbolName) => el.dispatchEvent(new CustomEvent(\"qSymbol\", {\n            detail: {\n                name: symbolName\n            },\n            bubbles: !0,\n            composed: !0\n        }));\n        const dispatch = async (element, eventName, ev) => {\n            for (const on of ON_PREFIXES) {\n                const attrValue = element.getAttribute(on + eventName);\n                if (attrValue) {\n                    element.hasAttribute(\"preventdefault:\" + eventName) && ev.preventDefault();\n                    for (const qrl of attrValue.split(\"\\n\")) {\n                        const url = qrlResolver(element, qrl, doc.baseURI);\n                        if (url) {\n                            const symbolName = getSymbolName(url);\n                            const handler = (window[url.pathname] || await import(url.href.split(\"#\")[0]))[symbolName] || error(url + \" does not export \" + symbolName);\n                            const previousCtx = doc.__q_context__;\n                            try {\n                                doc.__q_context__ = [ element, ev, url ];\n                                handler(ev, element, url);\n                            } finally {\n                                doc.__q_context__ = previousCtx;\n                                symbolUsed(element, symbolName);\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        const getSymbolName = url => url.hash.replace(/^#?([^?[|]*).*$/, \"$1\") || \"default\";\n        const processEvent = (ev, element) => {\n            if ((element = ev.target) == doc) {\n                setTimeout((() => broadcast(\"-document\", ev.type, ev)));\n            } else {\n                while (element && element.getAttribute) {\n                    dispatch(element, ev.type, ev);\n                    element = ev.bubbles ? element.parentElement : null;\n                }\n            }\n        };\n        const addEventListener = eventName => doc.addEventListener(eventName, processEvent, {\n            capture: !0\n        });\n        const processReadyStateChange = readyState => {\n            readyState = doc.readyState;\n            if (!hasInitialized && (\"interactive\" == readyState || \"complete\" == readyState)) {\n                hasInitialized = 1;\n                broadcast(\"\", \"q-init\", new CustomEvent(\"qInit\"));\n            }\n        };\n        {\n            const scriptTag = doc.querySelector(\"script[events]\");\n            if (scriptTag) {\n                scriptTag.getAttribute(\"events\").split(/[\\s,;]+/).forEach(addEventListener);\n            } else {\n                for (const key in doc) {\n                    key.startsWith(\"on\") && addEventListener(key.slice(2));\n                }\n            }\n        }\n        doc.addEventListener(\"readystatechange\", processReadyStateChange);\n        processReadyStateChange();\n    })(document);\n}();";
exports.QWIK_LOADER = QWIK_LOADER;
exports.QWIK_LOADER_DEBUG = QWIK_LOADER_DEBUG;
