const QWIK_LOADER = "((e,t)=>{const n=\"__q_context__\",o=window,s=new Set,a=\"replace\",i=\"forEach\",r=\"target\",c=\"getAttribute\",l=\"isConnected\",p=\"qvisible\",f=\"_qwikjson_\",u=t=>e.querySelectorAll(t),b=e=>e&&\"function\"==typeof e.then,d=(e,t,n=t.type)=>{u(\"[on\"+e+\"\\\\:\"+n+\"]\")[i]((o=>m(o,e,t,n)))},w=t=>{if(void 0===t[f]){let n=(t===e.documentElement?e.body:t).lastElementChild;for(;n;){if(\"SCRIPT\"===n.tagName&&\"qwik/json\"===n[c](\"type\")){t[f]=JSON.parse(n.textContent[a](/\\\\x3C(\\/?script)/gi,\"<$1\"));break}n=n.previousElementSibling}}},y=(e,t)=>new CustomEvent(e,{detail:t}),m=async(t,o,s,i=s.type)=>{const r=\"on\"+o+\":\"+i;t.hasAttribute(\"preventdefault:\"+i)&&s.preventDefault();const p=t._qc_,f=p&&p.li.filter((e=>e[0]===r));if(f&&f.length>0){for(const e of f){const n=e[1].getFn([t,s],(()=>t[l]))(s,t),o=s.cancelBubble;b(n)&&await n,o&&s.stopPropagation()}return}const u=t[c](r);if(u){const o=t.closest(\"[q\\\\:container]\"),i=new URL(o[c](\"q:base\"),e.baseURI);for(const r of u.split(\"\\n\")){const c=new URL(r,i),p=c.hash[a](/^#?([^?[|]*).*$/,\"$1\")||\"default\",f=performance.now();let u;const d=r.startsWith(\"#\");if(d)u=(o.qFuncs||[])[Number.parseInt(p)];else{const e=import(c.href.split(\"#\")[0]);w(o),u=(await e)[p]}const y=e[n];if(t[l])try{e[n]=[t,s,c],d||q(\"qsymbol\",{symbol:p,element:t,reqTime:f});const o=u(s,t);b(o)&&await o}finally{e[n]=y}}}},q=(t,n)=>{e.dispatchEvent(y(t,n))},v=e=>e[a](/([A-Z])/g,(e=>\"-\"+e.toLowerCase())),h=async e=>{let t=v(e.type),n=e[r];for(d(\"-document\",e,t);n&&n[c];){const o=m(n,\"\",e,t);let s=e.cancelBubble;b(o)&&await o,s=s||e.cancelBubble||n.hasAttribute(\"stoppropagation:\"+e.type),n=e.bubbles&&!0!==s?n.parentElement:null}},g=e=>{d(\"-window\",e,v(e.type))},_=()=>{var n;const a=e.readyState;if(!t&&(\"interactive\"==a||\"complete\"==a)&&(t=1,q(\"qinit\"),(null!=(n=o.requestIdleCallback)?n:o.setTimeout).bind(o)((()=>q(\"qidle\"))),s.has(p))){const e=u(\"[on\\\\:\"+p+\"]\"),t=new IntersectionObserver((e=>{for(const n of e)n.isIntersecting&&(t.unobserve(n[r]),m(n[r],\"\",y(p,n)))}));e[i]((e=>t.observe(e)))}},C=(e,t,n,o=!1)=>e.addEventListener(t,n,{capture:o,passive:!1}),E=t=>{for(const n of t)s.has(n)||(C(e,n,h,!0),C(o,n,g,!0),s.add(n))};if(!(n in e)){e[n]=0;const t=o.qwikevents;Array.isArray(t)&&E(t),o.qwikevents={push:(...e)=>E(e)},C(e,\"readystatechange\",_),_()}})(document)";
const QWIK_LOADER_DEBUG = "(() => {\n    ((doc, hasInitialized) => {\n        const Q_CONTEXT = \"__q_context__\";\n        const win = window;\n        const events =  new Set;\n        const querySelectorAll = query => doc.querySelectorAll(query);\n        const isPromise = promise => promise && \"function\" == typeof promise.then;\n        const broadcast = (infix, ev, type = ev.type) => {\n            querySelectorAll(\"[on\" + infix + \"\\\\:\" + type + \"]\").forEach((el => dispatch(el, infix, ev, type)));\n        };\n        const resolveContainer = containerEl => {\n            if (void 0 === containerEl._qwikjson_) {\n                let script = (containerEl === doc.documentElement ? doc.body : containerEl).lastElementChild;\n                while (script) {\n                    if (\"SCRIPT\" === script.tagName && \"qwik/json\" === script.getAttribute(\"type\")) {\n                        containerEl._qwikjson_ = JSON.parse(script.textContent.replace(/\\\\x3C(\\/?script)/gi, \"<$1\"));\n                        break;\n                    }\n                    script = script.previousElementSibling;\n                }\n            }\n        };\n        const createEvent = (eventName, detail) => new CustomEvent(eventName, {\n            detail: detail\n        });\n        const dispatch = async (element, onPrefix, ev, eventName = ev.type) => {\n            const attrName = \"on\" + onPrefix + \":\" + eventName;\n            element.hasAttribute(\"preventdefault:\" + eventName) && ev.preventDefault();\n            const ctx = element._qc_;\n            const relevantListeners = ctx && ctx.li.filter((li => li[0] === attrName));\n            if (relevantListeners && relevantListeners.length > 0) {\n                for (const listener of relevantListeners) {\n                    const results = listener[1].getFn([ element, ev ], (() => element.isConnected))(ev, element);\n                    const cancelBubble = ev.cancelBubble;\n                    isPromise(results) && await results;\n                    cancelBubble && ev.stopPropagation();\n                }\n                return;\n            }\n            const attrValue = element.getAttribute(attrName);\n            if (attrValue) {\n                const container = element.closest(\"[q\\\\:container]\");\n                const base = new URL(container.getAttribute(\"q:base\"), doc.baseURI);\n                for (const qrl of attrValue.split(\"\\n\")) {\n                    const url = new URL(qrl, base);\n                    const symbolName = url.hash.replace(/^#?([^?[|]*).*$/, \"$1\") || \"default\";\n                    const reqTime = performance.now();\n                    let handler;\n                    const isSync = qrl.startsWith(\"#\");\n                    if (isSync) {\n                        handler = (container.qFuncs || [])[Number.parseInt(symbolName)];\n                    } else {\n                        const module = import(\n                                                url.href.split(\"#\")[0]);\n                        resolveContainer(container);\n                        handler = (await module)[symbolName];\n                    }\n                    const previousCtx = doc[Q_CONTEXT];\n                    if (element.isConnected) {\n                        try {\n                            doc[Q_CONTEXT] = [ element, ev, url ];\n                            isSync || emitEvent(\"qsymbol\", {\n                                symbol: symbolName,\n                                element: element,\n                                reqTime: reqTime\n                            });\n                            const results = handler(ev, element);\n                            isPromise(results) && await results;\n                        } finally {\n                            doc[Q_CONTEXT] = previousCtx;\n                        }\n                    }\n                }\n            }\n        };\n        const emitEvent = (eventName, detail) => {\n            doc.dispatchEvent(createEvent(eventName, detail));\n        };\n        const camelToKebab = str => str.replace(/([A-Z])/g, (a => \"-\" + a.toLowerCase()));\n        const processDocumentEvent = async ev => {\n            let type = camelToKebab(ev.type);\n            let element = ev.target;\n            broadcast(\"-document\", ev, type);\n            while (element && element.getAttribute) {\n                const results = dispatch(element, \"\", ev, type);\n                let cancelBubble = ev.cancelBubble;\n                isPromise(results) && await results;\n                cancelBubble = cancelBubble || ev.cancelBubble || element.hasAttribute(\"stoppropagation:\" + ev.type);\n                element = ev.bubbles && !0 !== cancelBubble ? element.parentElement : null;\n            }\n        };\n        const processWindowEvent = ev => {\n            broadcast(\"-window\", ev, camelToKebab(ev.type));\n        };\n        const processReadyStateChange = () => {\n            var _a;\n            const readyState = doc.readyState;\n            if (!hasInitialized && (\"interactive\" == readyState || \"complete\" == readyState)) {\n                hasInitialized = 1;\n                emitEvent(\"qinit\");\n                (null != (_a = win.requestIdleCallback) ? _a : win.setTimeout).bind(win)((() => emitEvent(\"qidle\")));\n                if (events.has(\"qvisible\")) {\n                    const results = querySelectorAll(\"[on\\\\:qvisible]\");\n                    const observer = new IntersectionObserver((entries => {\n                        for (const entry of entries) {\n                            if (entry.isIntersecting) {\n                                observer.unobserve(entry.target);\n                                dispatch(entry.target, \"\", createEvent(\"qvisible\", entry));\n                            }\n                        }\n                    }));\n                    results.forEach((el => observer.observe(el)));\n                }\n            }\n        };\n        const addEventListener = (el, eventName, handler, capture = !1) => el.addEventListener(eventName, handler, {\n            capture: capture,\n            passive: !1\n        });\n        const push = eventNames => {\n            for (const eventName of eventNames) {\n                if (!events.has(eventName)) {\n                    addEventListener(doc, eventName, processDocumentEvent, !0);\n                    addEventListener(win, eventName, processWindowEvent, !0);\n                    events.add(eventName);\n                }\n            }\n        };\n        if (!(Q_CONTEXT in doc)) {\n            doc[Q_CONTEXT] = 0;\n            const qwikevents = win.qwikevents;\n            Array.isArray(qwikevents) && push(qwikevents);\n            win.qwikevents = {\n                push: (...e) => push(e)\n            };\n            addEventListener(doc, \"readystatechange\", processReadyStateChange);\n            processReadyStateChange();\n        }\n    })(document);\n})()";
exports.QWIK_LOADER = QWIK_LOADER;
exports.QWIK_LOADER_DEBUG = QWIK_LOADER_DEBUG;
