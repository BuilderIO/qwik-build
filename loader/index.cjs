const QWIK_LOADER = "((e,t,r)=>{const n=\"__q_context__\",o=[\"on:\",\"on-window:\",\"on-document:\"],s=(t,r,n)=>{r=r.replace(/([A-Z])/g,(e=>\"-\"+e.toLowerCase())),e.querySelectorAll(\"[on\"+t+\"\\\\:\"+r+\"]\").forEach((e=>l(e,r,n)))},a=(e,t)=>e.dispatchEvent(new CustomEvent(\"qsymbol\",{detail:{name:t},bubbles:!0,composed:!0})),i=e=>{throw Error(\"QWIK \"+e)},c=(t,r)=>(t=t.closest(\"[q\\\\:container]\"),new URL(r,new URL(t?t.getAttribute(\"q:base\"):e.baseURI,e.baseURI))),l=async(t,r,s)=>{for(const l of o){const o=t.getAttribute(l+r);if(o){t.hasAttribute(\"preventdefault:\"+r)&&s.preventDefault();for(const r of o.split(\"\\n\")){const o=c(t,r);if(o){const r=b(o),c=(window[o.pathname]||await import(o.href.split(\"#\")[0]))[r]||i(o+\" does not export \"+r),l=e[n];try{e[n]=[t,s,o],c(s,t,o)}finally{e[n]=l,a(t,r)}}}}}},b=e=>e.hash.replace(/^#?([^?[|]*).*$/,\"$1\")||\"default\",u=(t,r)=>{if((r=t.target)==e)setTimeout((()=>s(\"-document\",t.type,t)));else for(;r&&r.getAttribute;)l(r,t.type,t),r=t.bubbles?r.parentElement:null},f=e=>(r||(r=new Worker(URL.createObjectURL(new Blob(['addEventListener(\"message\",(e=>e.data.map((e=>fetch(e)))));'],{type:\"text/javascript\"})))),r.postMessage(e.getAttribute(\"q:prefetch\").split(\"\\n\").map((t=>c(e,t)+\"\"))),r),p=r=>{if(r=e.readyState,!t&&(\"interactive\"==r||\"complete\"==r)&&(t=1,console.log(\"hreferf\"),s(\"\",\"qresume\",new CustomEvent(\"qresume\")),e.querySelectorAll(\"[q\\\\:prefetch]\").forEach(f),\"undefined\"!=typeof IntersectionObserver)){const t=new IntersectionObserver((e=>{for(const r of e)r.isIntersecting&&(t.unobserve(r.target),l(r.target,\"qvisible\",new CustomEvent(\"qvisible\",{bubbles:!1,detail:r})))}));e.qO=t,new MutationObserver((e=>{for(const r of e)t.observe(r.target)})).observe(document.documentElement,{attributeFilter:[\"on:qvisible\"],subtree:!0}),e.querySelectorAll(\"[on\\\\:qvisible]\").forEach((e=>t.observe(e)))}},d=t=>e.addEventListener(t,u,{capture:!0});if(!e.qR){e.qR=1;{const t=e.querySelector(\"script[events]\");if(t)t.getAttribute(\"events\").split(/[\\s,;]+/).forEach(d);else for(const t in e)t.startsWith(\"on\")&&d(t.slice(2))}e.addEventListener(\"readystatechange\",p),p()}})(document);";
const QWIK_LOADER_DEBUG = "(() => {\n    ((doc, hasInitialized, prefetchWorker) => {\n        const ON_PREFIXES = [ \"on:\", \"on-window:\", \"on-document:\" ];\n        const broadcast = (infix, type, ev) => {\n            type = type.replace(/([A-Z])/g, (a => \"-\" + a.toLowerCase()));\n            doc.querySelectorAll(\"[on\" + infix + \"\\\\:\" + type + \"]\").forEach((target => dispatch(target, type, ev)));\n        };\n        const symbolUsed = (el, symbolName) => el.dispatchEvent(new CustomEvent(\"qsymbol\", {\n            detail: {\n                name: symbolName\n            },\n            bubbles: !0,\n            composed: !0\n        }));\n        const error = msg => {\n            throw new Error(\"QWIK \" + msg);\n        };\n        const qrlResolver = (element, qrl) => {\n            element = element.closest(\"[q\\\\:container]\");\n            return new URL(qrl, new URL(element ? element.getAttribute(\"q:base\") : doc.baseURI, doc.baseURI));\n        };\n        const dispatch = async (element, eventName, ev) => {\n            for (const onPrefix of ON_PREFIXES) {\n                const attrValue = element.getAttribute(onPrefix + eventName);\n                if (attrValue) {\n                    element.hasAttribute(\"preventdefault:\" + eventName) && ev.preventDefault();\n                    for (const qrl of attrValue.split(\"\\n\")) {\n                        const url = qrlResolver(element, qrl);\n                        if (url) {\n                            const symbolName = getSymbolName(url);\n                            const handler = (window[url.pathname] || await import(url.href.split(\"#\")[0]))[symbolName] || error(url + \" does not export \" + symbolName);\n                            const previousCtx = doc.__q_context__;\n                            try {\n                                doc.__q_context__ = [ element, ev, url ];\n                                handler(ev, element, url);\n                            } finally {\n                                doc.__q_context__ = previousCtx;\n                                symbolUsed(element, symbolName);\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        const getSymbolName = url => url.hash.replace(/^#?([^?[|]*).*$/, \"$1\") || \"default\";\n        const processEvent = (ev, element) => {\n            if ((element = ev.target) == doc) {\n                setTimeout((() => broadcast(\"-document\", ev.type, ev)));\n            } else {\n                while (element && element.getAttribute) {\n                    dispatch(element, ev.type, ev);\n                    element = ev.bubbles ? element.parentElement : null;\n                }\n            }\n        };\n        const qrlPrefetch = element => {\n            prefetchWorker || (prefetchWorker = new Worker(URL.createObjectURL(new Blob([ 'addEventListener(\"message\",(e=>e.data.map((e=>fetch(e)))));' ], {\n                type: \"text/javascript\"\n            }))));\n            prefetchWorker.postMessage(element.getAttribute(\"q:prefetch\").split(\"\\n\").map((qrl => qrlResolver(element, qrl) + \"\")));\n            return prefetchWorker;\n        };\n        const processReadyStateChange = readyState => {\n            readyState = doc.readyState;\n            if (!hasInitialized && (\"interactive\" == readyState || \"complete\" == readyState)) {\n                hasInitialized = 1;\n                console.log(\"hreferf\");\n                broadcast(\"\", \"qresume\", new CustomEvent(\"qresume\"));\n                doc.querySelectorAll(\"[q\\\\:prefetch]\").forEach(qrlPrefetch);\n                if (\"undefined\" != typeof IntersectionObserver) {\n                    const observer = new IntersectionObserver((entries => {\n                        for (const entry of entries) {\n                            if (entry.isIntersecting) {\n                                observer.unobserve(entry.target);\n                                dispatch(entry.target, \"qvisible\", new CustomEvent(\"qvisible\", {\n                                    bubbles: !1,\n                                    detail: entry\n                                }));\n                            }\n                        }\n                    }));\n                    doc.qO = observer;\n                    new MutationObserver((mutations => {\n                        for (const mutation2 of mutations) {\n                            observer.observe(mutation2.target);\n                        }\n                    })).observe(document.documentElement, {\n                        attributeFilter: [ \"on:qvisible\" ],\n                        subtree: !0\n                    });\n                    doc.querySelectorAll(\"[on\\\\:qvisible]\").forEach((el => observer.observe(el)));\n                }\n            }\n        };\n        const addDocEventListener = eventName => doc.addEventListener(eventName, processEvent, {\n            capture: !0\n        });\n        if (!doc.qR) {\n            doc.qR = 1;\n            {\n                const scriptTag = doc.querySelector(\"script[events]\");\n                if (scriptTag) {\n                    scriptTag.getAttribute(\"events\").split(/[\\s,;]+/).forEach(addDocEventListener);\n                } else {\n                    for (const key in doc) {\n                        key.startsWith(\"on\") && addDocEventListener(key.slice(2));\n                    }\n                }\n            }\n            doc.addEventListener(\"readystatechange\", processReadyStateChange);\n            processReadyStateChange();\n        }\n    })(document);\n})();";
exports.QWIK_LOADER = QWIK_LOADER;
exports.QWIK_LOADER_DEBUG = QWIK_LOADER_DEBUG;
