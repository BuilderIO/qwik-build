const QWIK_PREFETCH = "(()=>{const n=Number.MAX_SAFE_INTEGER>>>1;function e(e,a){const[i,o]=s(a),c=e.t.find((n=>i===n.i));if(c)return e.o(\"intercepting\",a.pathname),t(e,c,[o],n).then((()=>async function(n,e){const t=n.u.find((n=>n.l.pathname===e.pathname));return t?t.$:(n.o(\"CACHE HIT\",e.pathname),!n.p&&await n.h(),n.p.match(e))}(e,a)))}async function t(e,t,i,s){const c=new Set;i.forEach((n=>o(t.m,c,n))),await Promise.all(Array.from(c).map((a=>async function(e,t,a){let i=e.u.find((n=>n.l.pathname===t.pathname));const o=a>=n?\"direct\":\"prefetch\";if(i){const n=i.C?\"fetching\":\"waiting\";i.R<a?(e.o(\"queue update priority\",n,t.pathname),i.R=a):e.o(\"already in queue\",o,n,t.pathname)}else!e.p&&await e.h(),await e.p.match(t)||(e.o(\"enqueue\",o,t.pathname),i={R:a,l:t,H:null,$:null,C:!1},i.$=new Promise((n=>i.H=n)),e.u.push(i));return i}(e,new URL(t.i+a,e.l),s)))),a(e)}function a(e){e.u.sort(i);let t=0;for(const i of e.u)if(i.C)t++;else if(t<e.S||i.R>=n){i.C=!0,t++;const o=i.R>=n?\"FETCH (CACHE MISS)\":\"FETCH\";e.o(o,i.l.pathname),e.U(i.l).then((async n=>{if(200===n.status){const t=e.p;try{!t&&await e.h(),e.o(\"CACHED\",i.l.pathname),await e.p.put(i.l,n.clone())}finally{e.p=t}}i.H(n)})).finally((()=>{e.o(\"FETCH DONE\",i.l.pathname),e.u.splice(e.u.indexOf(i),1),a(e)}))}}function i(n,e){return e.R-n.R}function o(n,e,t){if(!e.has(t)){e.add(t);let a=n.findIndex((n=>n===t));if(-1!==a)for(;\"number\"==typeof n[++a];)o(n,e,n[n[a]])}return e}function s(n){const e=new URL(n).pathname,t=e.lastIndexOf(\"/\");return[e.substring(0,t+1),e.substring(t+1)]}const c=(...n)=>{console.log(\"⚙️ Prefetch SW:\",...n)};async function r(n,e,t,a){const i=n.t.findIndex((n=>n==n));if(-1!==i&&n.t.splice(i,1),n.o(\"adding base:\",e),n.t.push({i:e,m:t}),a){const a=new Set(t.filter((n=>\"string\"==typeof n)));!n.p&&await n.h();for(const t of await n.p.keys()){const[i,o]=s(new URL(t.url)),c=[];i!==e||a.has(o)||(n.o(\"deleting\",t.url),c.push(n.p.delete(t))),await Promise.all(c)}}}function u(n,e,a){const i=n.t.find((n=>e===n.i));i?t(n,i,a,0):console.error(`Base path not found: ${e}, ignoring prefetch.`)}function f(n){if(!n.L&&n.P.length){const t=n.P.shift();n.L=(async(n,t)=>{const a=t[0];n.o(\"received message:\",a,t[1],t.slice(2)),await n.h(),\"graph\"===a?await r(n,t[1],t.slice(2),!0):\"graph-url\"===a?await async function(n,t,a){await r(n,t,[],!1);const i=await e(n,new URL(t+a,n.l));if(i&&200===i.status){const e=await i.json();e.push(a),await r(n,t,e,!0)}}(n,t[1],t[2]):\"prefetch\"===a?await u(n,t[1],t.slice(2)):\"prefetch-all\"===a?await function(n,e){const t=n.t.find((n=>e===n.i));t?u(n,e,t.m.filter((n=>\"string\"==typeof n))):console.error(`Base path not found: ${e}, ignoring prefetch.`)}(n,t[1]):\"ping\"===a?c(\"ping\"):\"verbose\"===a?(n.o=c)(\"mode: verbose\"):console.error(\"UNKNOWN MESSAGE:\",t),n.p=null})(n,t).then((()=>{n.L=null,f(n)}))}}(n=>{const t={U:n.fetch.bind(n),u:[],t:[],p:null,h:null,P:[],L:null,S:10,l:new URL(n.location.href),o:()=>{}};n.addEventListener(\"fetch\",(async n=>{const a=n.request;if(\"GET\"===a.method){const i=t.p;try{!i&&await t.h();const o=e(t,new URL(a.url));o&&n.respondWith(o)}finally{t.p=i}}})),n.addEventListener(\"message\",(n=>{t.P.push(n.data),f(t)})),n.addEventListener(\"install\",(()=>n.skipWaiting())),n.addEventListener(\"activate\",(async e=>{e.waitUntil(n.clients.claim()),t.h=async()=>t.p=await n.caches.open(\"QwikBundles\")}))})(globalThis)})();";
const QWIK_PREFETCH_DEBUG = "(() => {\n    const DIRECT_PRIORITY = Number.MAX_SAFE_INTEGER >>> 1;\n    function directFetch(swState, url) {\n        const [basePath, filename] = parseBaseFilename(url);\n        const base = swState.$bases$.find((base2 => basePath === base2.$path$));\n        if (base) {\n            swState.$log$(\"intercepting\", url.pathname);\n            return enqueueFileAndDependencies(swState, base, [ filename ], DIRECT_PRIORITY).then((() => async function(swState, url) {\n                const currentRequestTask = swState.$queue$.find((task => task.$url$.pathname === url.pathname));\n                if (currentRequestTask) {\n                    return currentRequestTask.$response$;\n                }\n                swState.$log$(\"CACHE HIT\", url.pathname);\n                !swState.$cache$ && await swState.$openCache$();\n                return swState.$cache$.match(url);\n            }(swState, url)));\n        }\n    }\n    async function enqueueFileAndDependencies(swState, base, filenames, priority) {\n        const fetchSet =  new Set;\n        filenames.forEach((filename => addDependencies(base.$graph$, fetchSet, filename)));\n        await Promise.all(Array.from(fetchSet).map((filename => async function(swState, url, priority) {\n            let task = swState.$queue$.find((task2 => task2.$url$.pathname === url.pathname));\n            const mode = priority >= DIRECT_PRIORITY ? \"direct\" : \"prefetch\";\n            if (task) {\n                const state = task.$isFetching$ ? \"fetching\" : \"waiting\";\n                if (task.$priority$ < priority) {\n                    swState.$log$(\"queue update priority\", state, url.pathname);\n                    task.$priority$ = priority;\n                } else {\n                    swState.$log$(\"already in queue\", mode, state, url.pathname);\n                }\n            } else {\n                !swState.$cache$ && await swState.$openCache$();\n                if (!await swState.$cache$.match(url)) {\n                    swState.$log$(\"enqueue\", mode, url.pathname);\n                    task = {\n                        $priority$: priority,\n                        $url$: url,\n                        $resolveResponse$: null,\n                        $response$: null,\n                        $isFetching$: !1\n                    };\n                    task.$response$ = new Promise((resolve => task.$resolveResponse$ = resolve));\n                    swState.$queue$.push(task);\n                }\n            }\n            return task;\n        }(swState, new URL(base.$path$ + filename, swState.$url$), priority))));\n        taskTick(swState);\n    }\n    function taskTick(swState) {\n        swState.$queue$.sort(byFetchOrder);\n        let outstandingRequests = 0;\n        for (const task of swState.$queue$) {\n            if (task.$isFetching$) {\n                outstandingRequests++;\n            } else if (outstandingRequests < swState.$maxPrefetchRequests$ || task.$priority$ >= DIRECT_PRIORITY) {\n                task.$isFetching$ = !0;\n                outstandingRequests++;\n                const action = task.$priority$ >= DIRECT_PRIORITY ? \"FETCH (CACHE MISS)\" : \"FETCH\";\n                swState.$log$(action, task.$url$.pathname);\n                swState.$fetch$(task.$url$).then((async response => {\n                    if (200 === response.status) {\n                        const previousCache = swState.$cache$;\n                        try {\n                            !previousCache && await swState.$openCache$();\n                            swState.$log$(\"CACHED\", task.$url$.pathname);\n                            await swState.$cache$.put(task.$url$, response.clone());\n                        } finally {\n                            swState.$cache$ = previousCache;\n                        }\n                    }\n                    task.$resolveResponse$(response);\n                })).finally((() => {\n                    swState.$log$(\"FETCH DONE\", task.$url$.pathname);\n                    swState.$queue$.splice(swState.$queue$.indexOf(task), 1);\n                    taskTick(swState);\n                }));\n            }\n        }\n    }\n    function byFetchOrder(a, b) {\n        return b.$priority$ - a.$priority$;\n    }\n    function addDependencies(graph, fetchSet, filename) {\n        if (!fetchSet.has(filename)) {\n            fetchSet.add(filename);\n            let index = graph.findIndex((file => file === filename));\n            if (-1 !== index) {\n                while (\"number\" == typeof graph[++index]) {\n                    addDependencies(graph, fetchSet, graph[graph[index]]);\n                }\n            }\n        }\n        return fetchSet;\n    }\n    function parseBaseFilename(url) {\n        const pathname = new URL(url).pathname;\n        const slashIndex = pathname.lastIndexOf(\"/\");\n        return [ pathname.substring(0, slashIndex + 1), pathname.substring(slashIndex + 1) ];\n    }\n    const log = (...args) => {\n        console.log(\"⚙️ Prefetch SW:\", ...args);\n    };\n    const processMessage = async (state, msg) => {\n        const type = msg[0];\n        state.$log$(\"received message:\", type, msg[1], msg.slice(2));\n        await state.$openCache$();\n        \"graph\" === type ? await processBundleGraph(state, msg[1], msg.slice(2), !0) : \"graph-url\" === type ? await async function(swState, base, graphPath) {\n            await processBundleGraph(swState, base, [], !1);\n            const response = await directFetch(swState, new URL(base + graphPath, swState.$url$));\n            if (response && 200 === response.status) {\n                const graph = await response.json();\n                graph.push(graphPath);\n                await processBundleGraph(swState, base, graph, !0);\n            }\n        }(state, msg[1], msg[2]) : \"prefetch\" === type ? await processPrefetch(state, msg[1], msg.slice(2)) : \"prefetch-all\" === type ? await function(swState, basePath) {\n            const base = swState.$bases$.find((base2 => basePath === base2.$path$));\n            base ? processPrefetch(swState, basePath, base.$graph$.filter((item => \"string\" == typeof item))) : console.error(`Base path not found: ${basePath}, ignoring prefetch.`);\n        }(state, msg[1]) : \"ping\" === type ? log(\"ping\") : \"verbose\" === type ? (state.$log$ = log)(\"mode: verbose\") : console.error(\"UNKNOWN MESSAGE:\", msg);\n        state.$cache$ = null;\n    };\n    async function processBundleGraph(swState, base, graph, cleanup) {\n        const existingBaseIndex = swState.$bases$.findIndex((base2 => base2 == base2));\n        -1 !== existingBaseIndex && swState.$bases$.splice(existingBaseIndex, 1);\n        swState.$log$(\"adding base:\", base);\n        swState.$bases$.push({\n            $path$: base,\n            $graph$: graph\n        });\n        if (cleanup) {\n            const bundles = new Set(graph.filter((item => \"string\" == typeof item)));\n            !swState.$cache$ && await swState.$openCache$();\n            for (const request of await swState.$cache$.keys()) {\n                const [cacheBase, filename] = parseBaseFilename(new URL(request.url));\n                const promises = [];\n                if (cacheBase === base && !bundles.has(filename)) {\n                    swState.$log$(\"deleting\", request.url);\n                    promises.push(swState.$cache$.delete(request));\n                }\n                await Promise.all(promises);\n            }\n        }\n    }\n    function processPrefetch(swState, basePath, bundles) {\n        const base = swState.$bases$.find((base2 => basePath === base2.$path$));\n        base ? enqueueFileAndDependencies(swState, base, bundles, 0) : console.error(`Base path not found: ${basePath}, ignoring prefetch.`);\n    }\n    function drainMsgQueue(swState) {\n        if (!swState.$msgQueuePromise$ && swState.$msgQueue$.length) {\n            const top = swState.$msgQueue$.shift();\n            swState.$msgQueuePromise$ = processMessage(swState, top).then((() => {\n                swState.$msgQueuePromise$ = null;\n                drainMsgQueue(swState);\n            }));\n        }\n    }\n    (swScope => {\n        const swState = ((fetch, url) => ({\n            $fetch$: fetch,\n            $queue$: [],\n            $bases$: [],\n            $cache$: null,\n            $openCache$: null,\n            $msgQueue$: [],\n            $msgQueuePromise$: null,\n            $maxPrefetchRequests$: 10,\n            $url$: url,\n            $log$: (...args) => {}\n        }))(swScope.fetch.bind(swScope), new URL(swScope.location.href));\n        swScope.addEventListener(\"fetch\", (async ev => {\n            const request = ev.request;\n            if (\"GET\" === request.method) {\n                const previousCache = swState.$cache$;\n                try {\n                    !previousCache && await swState.$openCache$();\n                    const response = directFetch(swState, new URL(request.url));\n                    response && ev.respondWith(response);\n                } finally {\n                    swState.$cache$ = previousCache;\n                }\n            }\n        }));\n        swScope.addEventListener(\"message\", (ev => {\n            swState.$msgQueue$.push(ev.data);\n            drainMsgQueue(swState);\n        }));\n        swScope.addEventListener(\"install\", (() => swScope.skipWaiting()));\n        swScope.addEventListener(\"activate\", (async event => {\n            event.waitUntil(swScope.clients.claim());\n            swState.$openCache$ = async () => swState.$cache$ = await swScope.caches.open(\"QwikBundles\");\n        }));\n    })(globalThis);\n})();";
export { QWIK_PREFETCH, QWIK_PREFETCH_DEBUG };
