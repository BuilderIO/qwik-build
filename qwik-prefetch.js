(()=>{const n=Number.MAX_SAFE_INTEGER>>>1;function e(e,o){const[i,s]=a(o),c=e.t.find((n=>i===n.o));if(c)return e.i("intercepting",o.pathname),t(e,c,[s],n).then((()=>async function(n,e){const t=n.u.find((n=>n.l.pathname===e.pathname));return t?t.$:(n.i("CACHE HIT",e.pathname),(await n.p).match(e))}(e,o)))}async function t(e,t,i,a){const c=new Set;i.forEach((n=>s(t.h,c,n))),await Promise.all(Array.from(c).map((o=>async function(e,t,o){let i=e.u.find((n=>n.l.pathname===t.pathname));const s=o>=n?"direct":"prefetch";if(i){const n=i.m?"fetching":"waiting";i.C<o?(e.i("queue update priority",n,t.pathname),i.C=o):e.i("already in queue",s,n,t.pathname)}else await e.p.match(t)||(e.i("enqueue",s,t.pathname),i={C:o,l:t,R:null,$:null,m:!1},i.$=new Promise((n=>i.R=n)),e.u.push(i));return i}(e,new URL(t.o+o,e.l),a)))),o(e)}function o(e){e.u.sort(i);let t=0;for(const i of e.u)if(i.m)t++;else if(t<e.H||i.C>=n){i.m=!0,t++;const s=i.C>=n?"FETCH (CACHE MISS)":"FETCH";e.i(s,i.l.pathname),e.S(i.l).then((async n=>{if(200===n.status){const t=e.p;try{!t&&e.U(),e.i("CACHED",i.l.pathname),await e.p.put(i.l,n.clone())}finally{e.p=t}}i.R(n)})).finally((()=>{e.i("FETCH DONE",i.l.pathname),e.u.splice(e.u.indexOf(i),1),o(e)}))}}function i(n,e){return e.C-n.C}function s(n,e,t){if(!e.has(t)){e.add(t);let o=n.findIndex((n=>n===t));if(-1!==o)for(;"number"==typeof n[++o];)s(n,e,n[n[o]])}return e}function a(n){const e=new URL(n).pathname,t=e.lastIndexOf("/");return[e.substring(0,t+1),e.substring(t+1)]}const c=(...n)=>{console.log("⚙️ Prefetch SW:",...n)};async function r(n,e,t,o){const i=n.t.findIndex((n=>n==n));if(-1!==i&&n.t.splice(i,1),n.i("adding base:",e),n.t.push({o:e,h:t}),o){const o=new Set(t.filter((n=>"string"==typeof n)));for(const t of await n.p.keys()){const[i,s]=a(new URL(t.url)),c=[];i!==e||o.has(s)||(n.i("deleting",t.url),c.push(n.p.delete(t))),await Promise.all(c)}}}function u(n,e,o){const i=n.t.find((n=>e===n.o));i?t(n,i,o,0):console.error(`Base path not found: ${e}, ignoring prefetch.`)}function f(n){if(!n.L&&n.P.length){const t=n.P.shift();n.L=(async(n,t)=>{const o=t[0];n.i("received message:",o,t[1],t.slice(2)),await n.U(),"graph"===o?await r(n,t[1],t.slice(2),!0):"graph-url"===o?await async function(n,t,o){await r(n,t,[],!1);const i=await e(n,new URL(t+o,n.l));if(i&&200===i.status){const e=await i.json();e.push(o),await r(n,t,e,!0)}}(n,t[1],t[2]):"prefetch"===o?await u(n,t[1],t.slice(2)):"prefetch-all"===o?await function(n,e){const t=n.t.find((n=>e===n.o));t?u(n,e,t.h.filter((n=>"string"==typeof n))):console.error(`Base path not found: ${e}, ignoring prefetch.`)}(n,t[1]):"ping"===o?c("ping"):"verbose"===o?(n.i=c)("mode: verbose"):console.error("UNKNOWN MESSAGE:",t),n.p=null})(n,t).then((()=>{n.L=null,f(n)}))}}(n=>{const t={S:n.fetch.bind(n),u:[],t:[],p:null,U:null,P:[],L:null,H:10,l:new URL(n.location.href),i:()=>{}};n.addEventListener("fetch",(async n=>{const o=n.request;if("GET"===o.method){const i=t.p;try{!i&&t.U();const s=e(t,new URL(o.url));s&&n.respondWith(s)}finally{t.p=i}}})),n.addEventListener("message",(n=>{t.P.push(n.data),f(t)})),n.addEventListener("install",(()=>n.skipWaiting())),n.addEventListener("activate",(async e=>{e.waitUntil(n.clients.claim()),t.U=async()=>t.p=await n.caches.open("QwikBundles")}))})(globalThis)})();