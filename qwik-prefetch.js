(()=>{const n=Number.MAX_SAFE_INTEGER>>>1;function e(e,a){const[i,o]=s(a),c=e.t.find((n=>i===n.i));if(c)return e.o("intercepting",a.pathname),t(e,c,[o],n).then((()=>async function(n,e){const t=n.u.find((n=>n.l.pathname===e.pathname));return t?t.$:(n.o("CACHE HIT",e.pathname),!n.p&&await n.h(),n.p.match(e))}(e,a)))}async function t(e,t,i,s){const c=new Set;i.forEach((n=>o(t.m,c,n))),await Promise.all(Array.from(c).map((a=>async function(e,t,a){let i=e.u.find((n=>n.l.pathname===t.pathname));const o=a>=n?"direct":"prefetch";if(i){const n=i.C?"fetching":"waiting";i.R<a?(e.o("queue update priority",n,t.pathname),i.R=a):e.o("already in queue",o,n,t.pathname)}else!e.p&&await e.h(),await e.p.match(t)||(e.o("enqueue",o,t.pathname),i={R:a,l:t,H:null,$:null,C:!1},i.$=new Promise((n=>i.H=n)),e.u.push(i));return i}(e,new URL(t.i+a,e.l),s)))),a(e)}function a(e){e.u.sort(i);let t=0;for(const i of e.u)if(i.C)t++;else if(t<e.S||i.R>=n){i.C=!0,t++;const o=i.R>=n?"FETCH (CACHE MISS)":"FETCH";e.o(o,i.l.pathname),e.U(i.l).then((async n=>{if(200===n.status){const t=e.p;try{!t&&await e.h(),e.o("CACHED",i.l.pathname),await e.p.put(i.l,n.clone())}finally{e.p=t}}i.H(n)})).finally((()=>{e.o("FETCH DONE",i.l.pathname),e.u.splice(e.u.indexOf(i),1),a(e)}))}}function i(n,e){return e.R-n.R}function o(n,e,t){if(!e.has(t)){e.add(t);let a=n.findIndex((n=>n===t));if(-1!==a)for(;"number"==typeof n[++a];)o(n,e,n[n[a]])}return e}function s(n){const e=new URL(n).pathname,t=e.lastIndexOf("/");return[e.substring(0,t+1),e.substring(t+1)]}const c=(...n)=>{console.log("⚙️ Prefetch SW:",...n)};async function r(n,e,t,a){const i=n.t.findIndex((n=>n==n));if(-1!==i&&n.t.splice(i,1),n.o("adding base:",e),n.t.push({i:e,m:t}),a){const a=new Set(t.filter((n=>"string"==typeof n)));!n.p&&await n.h();for(const t of await n.p.keys()){const[i,o]=s(new URL(t.url)),c=[];i!==e||a.has(o)||(n.o("deleting",t.url),c.push(n.p.delete(t))),await Promise.all(c)}}}function u(n,e,a){const i=n.t.find((n=>e===n.i));i?t(n,i,a,0):console.error(`Base path not found: ${e}, ignoring prefetch.`)}function f(n){if(!n.L&&n.P.length){const t=n.P.shift();n.L=(async(n,t)=>{const a=t[0];n.o("received message:",a,t[1],t.slice(2)),await n.h(),"graph"===a?await r(n,t[1],t.slice(2),!0):"graph-url"===a?await async function(n,t,a){await r(n,t,[],!1);const i=await e(n,new URL(t+a,n.l));if(i&&200===i.status){const e=await i.json();e.push(a),await r(n,t,e,!0)}}(n,t[1],t[2]):"prefetch"===a?await u(n,t[1],t.slice(2)):"prefetch-all"===a?await function(n,e){const t=n.t.find((n=>e===n.i));t?u(n,e,t.m.filter((n=>"string"==typeof n))):console.error(`Base path not found: ${e}, ignoring prefetch.`)}(n,t[1]):"ping"===a?c("ping"):"verbose"===a?(n.o=c)("mode: verbose"):console.error("UNKNOWN MESSAGE:",t),n.p=null})(n,t).then((()=>{n.L=null,f(n)}))}}(n=>{const t={U:n.fetch.bind(n),u:[],t:[],p:null,h:null,P:[],L:null,S:10,l:new URL(n.location.href),o:()=>{}};n.addEventListener("fetch",(async n=>{const a=n.request;if("GET"===a.method){const i=t.p;try{!i&&await t.h();const o=e(t,new URL(a.url));o&&n.respondWith(o)}finally{t.p=i}}})),n.addEventListener("message",(n=>{t.P.push(n.data),f(t)})),n.addEventListener("install",(()=>n.skipWaiting())),n.addEventListener("activate",(async e=>{e.waitUntil(n.clients.claim()),t.h=async()=>t.p=await n.caches.open("QwikBundles")}))})(globalThis)})();