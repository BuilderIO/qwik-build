(()=>{const e=Number.MAX_SAFE_INTEGER>>>1;function t(t,i){const[s,o]=a(i),c=t.t.find((e=>s===e.i));if(c)return t.o("intercepting",i.pathname),n(t,c,[o],e).then((()=>function(e,t){const n=e.u.find((e=>e.l.pathname===t.pathname));return n?n.$:(e.o("CACHE HIT",t.pathname),e.h(t))}(t,i)))}async function n(t,n,s,a){const c=new Set;s.forEach((e=>o(n.p,c,e))),await Promise.all(Array.from(c).map((i=>async function(t,n,i){let s=t.u.find((e=>e.l.pathname===n.pathname));const o=i>=e?"direct":"prefetch";if(s){const e=s.m?"fetching":"waiting";s.C<i?(t.o("queue update priority",e,n.pathname),s.C=i):t.o("already in queue",o,e,n.pathname)}else await t.h(n)||(t.o("enqueue",o,n.pathname),s={C:i,l:n,v:null,$:null,m:!1},s.$=new Promise((e=>s.v=e)),t.u.push(s));return s}(t,new URL(n.i+i,t.l),a)))),i(t)}function i(t){t.u.sort(s);let n=0;for(const s of t.u)if(s.m)n++;else if(n<t.R||s.C>=e){s.m=!0,n++;const o=s.C>=e?"FETCH (CACHE MISS)":"FETCH";t.o(o,s.l.pathname),t.T(s.l).then((async e=>{s.v(e),200===e.status&&(t.o("CACHED",s.l.pathname),await t.H(s.l,e.clone()))})).finally((()=>{t.o("FETCH DONE",s.l.pathname),t.u.splice(t.u.indexOf(s),1),i(t)}))}}function s(e,t){return t.C-e.C}function o(e,t,n){if(!t.has(n)){t.add(n);let i=e.findIndex((e=>e===n));if(-1!==i)for(;"number"==typeof e[++i];)o(e,t,e[e[i]])}return t}function a(e){const t=new URL(e).pathname,n=t.lastIndexOf("/");return[t.substring(0,n+1),t.substring(n+1)]}const c=(...e)=>{console.log("⚙️ Prefetch SW:",...e)};async function r(e,t,n,i){const s=e.t.findIndex((e=>e==e));if(-1!==s&&e.t.splice(s,1),e.o("adding base:",t),e.t.push({i:t,p:n}),i){const i=new Set(n.filter((e=>"string"==typeof e))),s=await e.S();for(const n of await s.keys()){const[o,c]=a(new URL(n.url)),r=[];o!==t||i.has(c)||(e.o("deleting",n.url),r.push(s.delete(n))),await Promise.all(r)}}}function u(e,t,i){const s=e.t.find((e=>t===e.i));s?n(e,s,i,0):console.error(`Base path not found: ${t}, ignoring prefetch.`)}function f(e){if(!e.U&&e.L.length){const n=e.L.shift();e.U=(async(e,n)=>{const i=n[0];e.o("received message:",i,n[1],n.slice(2)),"graph"===i?await r(e,n[1],n.slice(2),!0):"graph-url"===i?await async function(e,n,i){await r(e,n,[],!1);const s=await t(e,new URL(n+i,e.l));if(s&&200===s.status){const t=await s.json();t.push(i),await r(e,n,t,!0)}}(e,n[1],n[2]):"prefetch"===i?await u(e,n[1],n.slice(2)):"prefetch-all"===i?await function(e,t){const n=e.t.find((e=>t===e.i));n?u(e,t,n.p.filter((e=>"string"==typeof e))):console.error(`Base path not found: ${t}, ignoring prefetch.`)}(e,n[1]):"ping"===i?c("ping"):"verbose"===i?(e.o=c)("mode: verbose"):console.error("UNKNOWN MESSAGE:",n)})(e,n).then((()=>{e.U=null,f(e)}))}}var l=Object.defineProperty,$=(e,t,n)=>(((e,t,n)=>{t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,"symbol"!=typeof t?t+"":t,n),n);class h{constructor(e,t){this.T=e,this.l=t,$(this,"$queue$",[]),$(this,"$bases$",[]),$(this,"$cache$",null),$(this,"$msgQueue$",[]),$(this,"$msgQueuePromise$",null),$(this,"$maxPrefetchRequests$",10)}S(){return this.P}async H(e,t){return(await this.S()).put(e,t)}async h(e){return(await this.S()).match(e)}o(){}}(e=>{const n=(i=e.fetch.bind(e),s=new URL(e.location.href),new h(i,s));var i,s;e.addEventListener("fetch",(e=>{const i=e.request;if("GET"===i.method){const s=t(n,new URL(i.url));s&&e.respondWith(s)}})),e.addEventListener("message",(e=>{n.L.push(e.data),f(n)})),e.addEventListener("install",(()=>e.skipWaiting())),e.addEventListener("activate",(t=>{n.S=()=>n.P?n.P:(clearTimeout(void 0),setTimeout((()=>{n.P=null}),5e3),e.caches.open("QwikBundles")),t.waitUntil(e.clients.claim())}))})(globalThis)})();