const QWIK_PREFETCH = "(()=>{const e=Number.MAX_SAFE_INTEGER>>>1;function t(t,i){const[s,o]=a(i),c=t.t.find((e=>s===e.i));if(c)return t.o(\"intercepting\",i.pathname),n(t,c,[o],e).then((()=>function(e,t){const n=e.u.find((e=>e.l.pathname===t.pathname));return n?n.$:(e.o(\"CACHE HIT\",t.pathname),e.h(t))}(t,i)))}async function n(t,n,s,a){const c=new Set;s.forEach((e=>o(n.p,c,e))),await Promise.all(Array.from(c).map((i=>async function(t,n,i){let s=t.u.find((e=>e.l.pathname===n.pathname));const o=i>=e?\"direct\":\"prefetch\";if(s){const e=s.m?\"fetching\":\"waiting\";s.C<i?(t.o(\"queue update priority\",e,n.pathname),s.C=i):t.o(\"already in queue\",o,e,n.pathname)}else await t.h(n)||(t.o(\"enqueue\",o,n.pathname),s={C:i,l:n,v:null,$:null,m:!1},s.$=new Promise((e=>s.v=e)),t.u.push(s));return s}(t,new URL(n.i+i,t.l),a)))),i(t)}function i(t){t.u.sort(s);let n=0;for(const s of t.u)if(s.m)n++;else if(n<t.R||s.C>=e){s.m=!0,n++;const o=s.C>=e?\"FETCH (CACHE MISS)\":\"FETCH\";t.o(o,s.l.pathname),t.T(s.l).then((async e=>{s.v(e),200===e.status&&(t.o(\"CACHED\",s.l.pathname),await t.H(s.l,e.clone()))})).finally((()=>{t.o(\"FETCH DONE\",s.l.pathname),t.u.splice(t.u.indexOf(s),1),i(t)}))}}function s(e,t){return t.C-e.C}function o(e,t,n){if(!t.has(n)){t.add(n);let i=e.findIndex((e=>e===n));if(-1!==i)for(;\"number\"==typeof e[++i];)o(e,t,e[e[i]])}return t}function a(e){const t=new URL(e).pathname,n=t.lastIndexOf(\"/\");return[t.substring(0,n+1),t.substring(n+1)]}const c=(...e)=>{console.log(\"⚙️ Prefetch SW:\",...e)};async function r(e,t,n,i){const s=e.t.findIndex((e=>e==e));if(-1!==s&&e.t.splice(s,1),e.o(\"adding base:\",t),e.t.push({i:t,p:n}),i){const i=new Set(n.filter((e=>\"string\"==typeof e))),s=await e.S();for(const n of await s.keys()){const[o,c]=a(new URL(n.url)),r=[];o!==t||i.has(c)||(e.o(\"deleting\",n.url),r.push(s.delete(n))),await Promise.all(r)}}}function u(e,t,i){const s=e.t.find((e=>t===e.i));s?n(e,s,i,0):console.error(`Base path not found: ${t}, ignoring prefetch.`)}function f(e){if(!e.U&&e.L.length){const n=e.L.shift();e.U=(async(e,n)=>{const i=n[0];e.o(\"received message:\",i,n[1],n.slice(2)),\"graph\"===i?await r(e,n[1],n.slice(2),!0):\"graph-url\"===i?await async function(e,n,i){await r(e,n,[],!1);const s=await t(e,new URL(n+i,e.l));if(s&&200===s.status){const t=await s.json();t.push(i),await r(e,n,t,!0)}}(e,n[1],n[2]):\"prefetch\"===i?await u(e,n[1],n.slice(2)):\"prefetch-all\"===i?await function(e,t){const n=e.t.find((e=>t===e.i));n?u(e,t,n.p.filter((e=>\"string\"==typeof e))):console.error(`Base path not found: ${t}, ignoring prefetch.`)}(e,n[1]):\"ping\"===i?c(\"ping\"):\"verbose\"===i?(e.o=c)(\"mode: verbose\"):console.error(\"UNKNOWN MESSAGE:\",n)})(e,n).then((()=>{e.U=null,f(e)}))}}var l=Object.defineProperty,$=(e,t,n)=>(((e,t,n)=>{t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,\"symbol\"!=typeof t?t+\"\":t,n),n);class h{constructor(e,t){this.T=e,this.l=t,$(this,\"$queue$\",[]),$(this,\"$bases$\",[]),$(this,\"$cache$\",null),$(this,\"$msgQueue$\",[]),$(this,\"$msgQueuePromise$\",null),$(this,\"$maxPrefetchRequests$\",10)}S(){return this.P}async H(e,t){return(await this.S()).put(e,t)}async h(e){return(await this.S()).match(e)}o(){}}(e=>{const n=(i=e.fetch.bind(e),s=new URL(e.location.href),new h(i,s));var i,s;e.addEventListener(\"fetch\",(e=>{const i=e.request;if(\"GET\"===i.method){const s=t(n,new URL(i.url));s&&e.respondWith(s)}})),e.addEventListener(\"message\",(e=>{n.L.push(e.data),f(n)})),e.addEventListener(\"install\",(()=>e.skipWaiting())),e.addEventListener(\"activate\",(t=>{n.S=()=>n.P?n.P:(clearTimeout(void 0),setTimeout((()=>{n.P=null}),5e3),e.caches.open(\"QwikBundles\")),t.waitUntil(e.clients.claim())}))})(globalThis)})();";
const QWIK_PREFETCH_DEBUG = "(() => {\n    const DIRECT_PRIORITY = Number.MAX_SAFE_INTEGER >>> 1;\n    function directFetch(swState, url) {\n        const [basePath, filename] = parseBaseFilename(url);\n        const base = swState.$bases$.find((base2 => basePath === base2.$path$));\n        if (base) {\n            swState.$log$(\"intercepting\", url.pathname);\n            return enqueueFileAndDependencies(swState, base, [ filename ], DIRECT_PRIORITY).then((() => function(swState, url) {\n                const currentRequestTask = swState.$queue$.find((task => task.$url$.pathname === url.pathname));\n                if (currentRequestTask) {\n                    return currentRequestTask.$response$;\n                }\n                swState.$log$(\"CACHE HIT\", url.pathname);\n                return swState.$match$(url);\n            }(swState, url)));\n        }\n    }\n    async function enqueueFileAndDependencies(swState, base, filenames, priority) {\n        const fetchSet =  new Set;\n        filenames.forEach((filename => addDependencies(base.$graph$, fetchSet, filename)));\n        await Promise.all(Array.from(fetchSet).map((filename => async function(swState, url, priority) {\n            let task = swState.$queue$.find((task2 => task2.$url$.pathname === url.pathname));\n            const mode = priority >= DIRECT_PRIORITY ? \"direct\" : \"prefetch\";\n            if (task) {\n                const state = task.$isFetching$ ? \"fetching\" : \"waiting\";\n                if (task.$priority$ < priority) {\n                    swState.$log$(\"queue update priority\", state, url.pathname);\n                    task.$priority$ = priority;\n                } else {\n                    swState.$log$(\"already in queue\", mode, state, url.pathname);\n                }\n            } else {\n                if (!await swState.$match$(url)) {\n                    swState.$log$(\"enqueue\", mode, url.pathname);\n                    task = {\n                        $priority$: priority,\n                        $url$: url,\n                        $resolveResponse$: null,\n                        $response$: null,\n                        $isFetching$: !1\n                    };\n                    task.$response$ = new Promise((resolve => task.$resolveResponse$ = resolve));\n                    swState.$queue$.push(task);\n                }\n            }\n            return task;\n        }(swState, new URL(base.$path$ + filename, swState.$url$), priority))));\n        taskTick(swState);\n    }\n    function taskTick(swState) {\n        swState.$queue$.sort(byFetchOrder);\n        let outstandingRequests = 0;\n        for (const task of swState.$queue$) {\n            if (task.$isFetching$) {\n                outstandingRequests++;\n            } else if (outstandingRequests < swState.$maxPrefetchRequests$ || task.$priority$ >= DIRECT_PRIORITY) {\n                task.$isFetching$ = !0;\n                outstandingRequests++;\n                const action = task.$priority$ >= DIRECT_PRIORITY ? \"FETCH (CACHE MISS)\" : \"FETCH\";\n                swState.$log$(action, task.$url$.pathname);\n                swState.$fetch$(task.$url$).then((async response => {\n                    task.$resolveResponse$(response);\n                    if (200 === response.status) {\n                        swState.$log$(\"CACHED\", task.$url$.pathname);\n                        await swState.$put$(task.$url$, response.clone());\n                    }\n                })).finally((() => {\n                    swState.$log$(\"FETCH DONE\", task.$url$.pathname);\n                    swState.$queue$.splice(swState.$queue$.indexOf(task), 1);\n                    taskTick(swState);\n                }));\n            }\n        }\n    }\n    function byFetchOrder(a, b) {\n        return b.$priority$ - a.$priority$;\n    }\n    function addDependencies(graph, fetchSet, filename) {\n        if (!fetchSet.has(filename)) {\n            fetchSet.add(filename);\n            let index = graph.findIndex((file => file === filename));\n            if (-1 !== index) {\n                while (\"number\" == typeof graph[++index]) {\n                    addDependencies(graph, fetchSet, graph[graph[index]]);\n                }\n            }\n        }\n        return fetchSet;\n    }\n    function parseBaseFilename(url) {\n        const pathname = new URL(url).pathname;\n        const slashIndex = pathname.lastIndexOf(\"/\");\n        return [ pathname.substring(0, slashIndex + 1), pathname.substring(slashIndex + 1) ];\n    }\n    const log = (...args) => {\n        console.log(\"⚙️ Prefetch SW:\", ...args);\n    };\n    const processMessage = async (state, msg) => {\n        const type = msg[0];\n        state.$log$(\"received message:\", type, msg[1], msg.slice(2));\n        \"graph\" === type ? await processBundleGraph(state, msg[1], msg.slice(2), !0) : \"graph-url\" === type ? await async function(swState, base, graphPath) {\n            await processBundleGraph(swState, base, [], !1);\n            const response = await directFetch(swState, new URL(base + graphPath, swState.$url$));\n            if (response && 200 === response.status) {\n                const graph = await response.json();\n                graph.push(graphPath);\n                await processBundleGraph(swState, base, graph, !0);\n            }\n        }(state, msg[1], msg[2]) : \"prefetch\" === type ? await processPrefetch(state, msg[1], msg.slice(2)) : \"prefetch-all\" === type ? await function(swState, basePath) {\n            const base = swState.$bases$.find((base2 => basePath === base2.$path$));\n            base ? processPrefetch(swState, basePath, base.$graph$.filter((item => \"string\" == typeof item))) : console.error(`Base path not found: ${basePath}, ignoring prefetch.`);\n        }(state, msg[1]) : \"ping\" === type ? log(\"ping\") : \"verbose\" === type ? (state.$log$ = log)(\"mode: verbose\") : console.error(\"UNKNOWN MESSAGE:\", msg);\n    };\n    async function processBundleGraph(swState, base, graph, cleanup) {\n        const existingBaseIndex = swState.$bases$.findIndex((base2 => base2 == base2));\n        -1 !== existingBaseIndex && swState.$bases$.splice(existingBaseIndex, 1);\n        swState.$log$(\"adding base:\", base);\n        swState.$bases$.push({\n            $path$: base,\n            $graph$: graph\n        });\n        if (cleanup) {\n            const bundles = new Set(graph.filter((item => \"string\" == typeof item)));\n            const cache = await swState.$getCache$();\n            for (const request of await cache.keys()) {\n                const [cacheBase, filename] = parseBaseFilename(new URL(request.url));\n                const promises = [];\n                if (cacheBase === base && !bundles.has(filename)) {\n                    swState.$log$(\"deleting\", request.url);\n                    promises.push(cache.delete(request));\n                }\n                await Promise.all(promises);\n            }\n        }\n    }\n    function processPrefetch(swState, basePath, bundles) {\n        const base = swState.$bases$.find((base2 => basePath === base2.$path$));\n        base ? enqueueFileAndDependencies(swState, base, bundles, 0) : console.error(`Base path not found: ${basePath}, ignoring prefetch.`);\n    }\n    function drainMsgQueue(swState) {\n        if (!swState.$msgQueuePromise$ && swState.$msgQueue$.length) {\n            const top = swState.$msgQueue$.shift();\n            swState.$msgQueuePromise$ = processMessage(swState, top).then((() => {\n                swState.$msgQueuePromise$ = null;\n                drainMsgQueue(swState);\n            }));\n        }\n    }\n    var __defProp = Object.defineProperty;\n    var __publicField = (obj, key, value) => {\n        ((obj, key, value) => {\n            key in obj ? __defProp(obj, key, {\n                enumerable: !0,\n                configurable: !0,\n                writable: !0,\n                value: value\n            }) : obj[key] = value;\n        })(obj, \"symbol\" != typeof key ? key + \"\" : key, value);\n        return value;\n    };\n    class SWStateImpl {\n        constructor($fetch$, $url$) {\n            this.$fetch$ = $fetch$;\n            this.$url$ = $url$;\n            __publicField(this, \"$queue$\", []);\n            __publicField(this, \"$bases$\", []);\n            __publicField(this, \"$cache$\", null);\n            __publicField(this, \"$msgQueue$\", []);\n            __publicField(this, \"$msgQueuePromise$\", null);\n            __publicField(this, \"$maxPrefetchRequests$\", 10);\n        }\n        $getCache$() {\n            return this.$cache$;\n        }\n        async $put$(request, response) {\n            return (await this.$getCache$()).put(request, response);\n        }\n        async $match$(request) {\n            return (await this.$getCache$()).match(request);\n        }\n        $log$() {}\n    }\n    (swScope => {\n        const swState = ((fetch, url) => new SWStateImpl(fetch, url))(swScope.fetch.bind(swScope), new URL(swScope.location.href));\n        swScope.addEventListener(\"fetch\", (ev => {\n            const request = ev.request;\n            if (\"GET\" === request.method) {\n                const response = directFetch(swState, new URL(request.url));\n                response && ev.respondWith(response);\n            }\n        }));\n        swScope.addEventListener(\"message\", (ev => {\n            swState.$msgQueue$.push(ev.data);\n            drainMsgQueue(swState);\n        }));\n        swScope.addEventListener(\"install\", (() => swScope.skipWaiting()));\n        swScope.addEventListener(\"activate\", (event => {\n            swState.$getCache$ = () => {\n                if (swState.$cache$) {\n                    return swState.$cache$;\n                }\n                clearTimeout(undefined);\n                setTimeout((() => {\n                    swState.$cache$ = null;\n                }), 5e3);\n                return swScope.caches.open(\"QwikBundles\");\n            };\n            event.waitUntil(swScope.clients.claim());\n        }));\n    })(globalThis);\n})();";
exports.QWIK_PREFETCH = QWIK_PREFETCH;
exports.QWIK_PREFETCH_DEBUG = QWIK_PREFETCH_DEBUG;
